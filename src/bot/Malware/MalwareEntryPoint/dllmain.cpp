#include <QApplication>
#include <QMessageBox>
#include <QObject>
#include <QThread>
#include <QPushButton>
#include <QWindow>
#include <Windows.h>
#include "myt.h"

#include <string>
#include <iostream>
#include <thread>

using namespace std;

char ** argv = nullptr;
QApplication * app = nullptr;
QPushButton * w;
MyT * t = nullptr;
thread * t1;


void WINAPI qtThread()
{
    int argc = 0;
    QCoreApplication::addLibraryPath("C:\\Qt");
    app = new QApplication(argc, NULL);
    w = new QPushButton();
    QObject::connect(w, SIGNAL(clicked(bool)), app, SLOT(aboutQt()));
    w->setText("About Qt");
    w->show();
    app->exec();
}

/**
 * @brief The entry point of the DLL that starts the malware code.
 * @param hinstDLL handle to DLL module
 * @param fdwReason reason for calling function
 * @param lpReserved reserved
 * @return Returns TRUE if the injection succeed, otherwise FALSE.
 * @see https://msdn.microsoft.com/en-us/library/windows/desktop/ms682596(v=vs.85).aspx
 */
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpReserved )
{
    // Perform actions based on the reason for calling.
    switch( fdwReason )
    {
        case DLL_PROCESS_ATTACH:
            // Initialize once for each new process.
            // Disable the call of the event for threads attach/detach
            DisableThreadLibraryCalls(hinstDLL);

            // Start a new thread to handle Qt code
            if ( CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)qtThread, NULL, 0, NULL) == NULL ) {
                return FALSE;
            }

            break;

        case DLL_THREAD_ATTACH:
            // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
            // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
            // Perform any necessary cleanup.
            break;
    }

    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}
